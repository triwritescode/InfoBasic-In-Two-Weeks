---
type: concept
tags:
  - Programming
  - InfoBasic
---
## String Fundamentals

**Nature**

- Strings are the default value type; variables are untyped.
- Empty string `''` is falsy; anything else is truthy.
    
**Build & slice**

```basic
FULL = "Mr " : "Adi"          ;* concat with :
HEAD = FULL[1,2]              ;* 1-based substring → "Mr"
L   = LEN(FULL)               ;* length
PAD = STR("0", 3)             ;* "000"
```

**Clean & case**

```basic
NAME = TRIM("  Adi  ")        ;* "Adi"
UP   = UPCASE("Idr")          ;* "IDR"
LO   = LOWCASE("IDR")         ;* "idr"
```

**Gotcha (precedence):** `:` binds **weaker** than `+ - * /`.

```basic
S = "A" : 1 + 2      ;* "A3"  (1+2 first)
S = "A" : (1 + 2)    ;* explicit & safe
```

---
## Finding & Replacing

**Substring search**

```basic
POS = INDEX(UPCASE(TEXT), "ERROR", 1)   ;* 0 = not found, else 1-based
```

**Whole-word check (safe)**

```basic
U = " " : UPCASE(TEXT) : " "
IF INDEX(U, " ERROR ", 1) > 0 THEN ...
; or:
IF UPCASE(TEXT) MATCHES "0X' ERROR '0X" THEN ...
```

**Replace substrings (can grow/shrink)**

```basic
CHANGE "  " TO " " IN NAME         ;* collapse double spaces
CHANGE "ID " TO "ID-" IN DOC
```

**Character map (1:1, fast)**

```basic
CONVERT "," TO @VM IN LIST         ;* CSV → @VM list
CONVERT @VM TO "," IN LIST         ;* @VM list → CSV
```

- `CONVERT` replaces **each character** in `from` with the **char at the same position** in `to`.
- Use `CHANGE` for multi-character patterns; use `CONVERT` for delimiter swaps, case maps, etc.

---
## MultiValue Marks (internal delimiters)

- `@FM` (attribute / field mark, char 254)
- `@VM` (value / multivalue mark, char 253)
- `@SM` (subvalue mark, char 252)

**Tip:** Keep these **inside** records/lists; convert to user-friendly delimiters at output boundaries.

---
## Delimited Text ⇄ MV Lists

**CSV/pipe to MV**

```basic
CSV = "IDR,USD,EUR"
MV  = CSV
CONVERT "," TO @VM IN MV                 ;* now "IDR@VMUSD@VMEUR"
N = DCOUNT(MV, @VM)                      ;* 3
```

**MV to CSV**

```basic
LINE = MV
CONVERT @VM TO "," IN LINE
```

**Nth token (without MV)**

```basic
C = FIELD("JKT|BDG|SBY","|",2)           ;* "BDG"
```

**Exact item membership (MV, best)**

```basic
IF LOCATE("USD") IN MV SETTING POS THEN ...
```

**Exact item membership (plain delimited text)**

```basic
SAFE = "," : UPCASE(LIST) : ","
NEED = "," : UPCASE(ITEM) : ","
IF INDEX(SAFE, NEED, 1) > 0 THEN ...     ;* avoids "US" matching "USD"
```

---
## Numbers ⇄ Strings

**Implicit coercion**

- In `+ - * /`, strings are coerced to numbers. Non-numeric → `0`.

```basic
IF NUM(AMT) THEN NET = AMT - FEE ELSE NET = 0
```

**Rounding & formatting (always explicit at boundaries)**

```basic
AMT   = ROUND(1.235, 2)                  ;* 1.24 (numeric)
OUTMD = OCONV(AMT, "MD2")                ;* "1.24"
OUTMR = OCONV(AMT, "MR2")                ;* "1.24" with money rules
```

**Common masks**

- `MDn` → fixed decimals (e.g., `MD2`)
- `MRn` → money rules (rounding/zero suppression)
- Use `ICONV` when parsing numeric text that uses locale-specific formats (rare on TAFJ—prefer canonical dot-decimal).

---
## Dates/Times ⇄ Strings

**Internal forms**

- Date = integer day count
- Time = seconds past midnight

**Parse external → internal**

```basic
d1 = ICONV("15/09/2025","D/E")           ;* DD/MM/YYYY
d2 = ICONV("2025-09-15","D4-")           ;* YYYY-MM-DD
```

**Format internal → external**

```basic
S  = OCONV(d1, "D4-")                    ;* "2025-09-15"
T  = OCONV(TIME(), "MT")                 ;* "HH:MM:SS"
```

**Date math**

```basic
DUE = d1 + 7                             ;* add days
```

**Best practice:** Keep dates **internal** in all logic; convert only at input/output.

---
## Boundary-Safe Output (OFS / reports)

**Always sanitize & format**

```basic
AMT.TXT  = OCONV(ROUND(AMT,2),"MR2")
DATE.TXT = OCONV(DATE(), "D4-")

DESC = MEMO
CHANGE @FM TO " " IN DESC
CHANGE @VM TO " " IN DESC

OFS = "AMT=":AMT.TXT:@VM:"DATE=":DATE.TXT:@VM:"DESC=":DESC
```

---
# Common Micro-Recipes

### **1. Case-insensitive substring**

```basic
FUNCTION CONTAINS(STR, NEEDLE)    
	RETURN INDEX(UPCASE(STR), UPCASE(NEEDLE), 1) > 0 
END
```

### **2. Whole-word check**

```basic
FUNCTION CONTAINS.WORD(S, W)    
	U = " " : UPCASE(S) : " "    
	K = " " : UPCASE(W) : " "    
	RETURN INDEX(U, K, 1) > 0 
END
```

### **3. Normalize phone (keep digits)**

```basic
CLEAN = PHONE 
CONVERT "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz ()-+./" TO "" IN CLEAN
```

CLEAN now mostly digits (adjust the from-set as needed)

### **4. CSV ⇄ MV utility**

```basic
FUNCTION CSV.TO.MV(CSV)    
	MV = CSV ; CONVERT "," TO @VM IN MV ; RETURN MV 
END 

FUNCTION MV.TO.CSV(MV)    
	S = MV ; CONVERT @VM TO "," IN S ; RETURN S 
END
```

### **5. Parse two date formats with fallback**

```basic
FUNCTION PARSE.DATE(S)    
	IF S = '' THEN RETURN 0    
	D = ICONV(S,"D/E") ; IF D # 0 THEN RETURN D    
	RETURN ICONV(S,"D4-") 
END
```

---
## Pitfalls & Defensive Habits

- **Concat vs add:** `"1" : 2` → `"12"` vs `"1" + 2` → `3`. Be explicit.
- **Numeric vs lexicographic compares:** If both sides look numeric → numeric compare; else string compare. Guard with `NUM()`.
- **Don’t leak MV marks:** Convert `@FM/@VM/@SM` to user delimiters before display or export.
- **Hoist conversions:** Do `UPCASE/OCONV` once per record, not inside tight loops.
- **Short critical sections:** Do heavy string work **before** taking record locks (`READU`), then write and `RELEASE` quickly.

---
## Cheatsheet
|Task|Use|
|---|---|
|Concat / Slice|`A : B` / `S[p,n]`|
|Trim / Case|`TRIM`, `UPCASE`, `LOWCASE`, `LEN`, `STR`|
|Find / Replace|`INDEX`, `CHANGE`, `CONVERT`|
|Tokens|`FIELD(text, delim, n[,count])`|
|MV marks|`@FM` / `@VM` / `@SM`|
|CSV ⇄ MV|`CONVERT ","↔@VM`|
|Format number|`OCONV(x,"MD2"/"MR2")`, `ROUND(x,n)`|
|Parse/format date|`ICONV(ext,"D/E"/"D4-")`, `OCONV(int,"D4-")`, `OCONV(TIME(),"MT")`|
|Whole-word contains|wrap with spaces or `MATCHES`|