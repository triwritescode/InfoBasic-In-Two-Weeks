---
type: concept
tags:
  - Programming
  - InfoBasic
---
## What & why

- **Record I/O** = open/read/write/delete records in MV files.
- **Locking** = take an **exclusive update lock** while you edit so no one else can change the same key. Prevents **lost updates** and race conditions.

---
## Core statements (memorize these)

```basic
OPEN "ACCOUNT" TO F.ACCT ELSE ABORT 201,"ACCOUNT"   ;* open file

READ   R FROM F.ACCT, ID ELSE ...                   ;* read (no lock)
READU  R FROM F.ACCT, ID LOCKED ... ELSE ...        ;* read + update lock

WRITE  R  ON F.ACCT, ID                              ;* write (no lock)
WRITEU R  ON F.ACCT, ID                              ;* write while still locked

DELETE  F.ACCT, ID                                   ;* delete (no lock)
DELETEU F.ACCT, ID                                   ;* delete under lock

RELEASE F.ACCT                                       ;* release locks you hold on this file
```

- `READ` = safe for reporting.  
- `READU` = **always** use before modifying.  
- `WRITEU` **does not unlock** → you must `RELEASE`.

---
## Canonical safe update (read-modify-write)

```basic
OPEN "ACCOUNT" TO F.ACCT ELSE ABORT 201,"ACCOUNT"
ID = "100123"

* Lock & fetch (handle busy / not found)
READU R FROM F.ACCT, ID LOCKED GOTO BUSY ELSE GOTO NOTFND

* Validate on the locked copy (avoid TOCTOU)
IF NOT(NUM(R<10>)) THEN GOTO FAIL        ;* e.g., balance must be numeric

* Modify
R<10> = R<10> + 100

* Persist while still locked
WRITEU R ON F.ACCT, ID

* Unlock
RELEASE F.ACCT
RETURN

BUSY:    ;* someone else holds the lock → retry/backoff/skip
RETURN
NOTFND:  ;* key doesn’t exist
RETURN
FAIL:
RELEASE F.ACCT
RETURN
```

**Principles**
- **Lock before you read** what you’ll change.
- **Validate while locked**, then write and **release quickly**.

---
## Contention handling (LOCKED) — bounded retry

```basic
OK = 0
FOR T = 1 TO 3
  READU R FROM F.ACCT, ID LOCKED
     CALL SLEEP.MS(100*T) ; CONTINUE      ;* backoff
  END ELSE
     RETURN                                  ;* not found
  END
  OK = 1 ; EXIT
NEXT T
IF NOT(OK) THEN RETURN                        ;* give up this ID
```

Keep the critical section tiny to reduce contention.

---

## Attribute-level I/O (READV/WRITEV)

```basic
READU R FROM F.ACCT, ID ELSE RETURN
READV BAL FROM F.ACCT, ID, 10 ELSE BAL = 0
BAL += 100
WRITEV BAL ON F.ACCT, ID, 10
WRITEU R ON F.ACCT, ID
RELEASE F.ACCT
```

- Even with `READV/WRITEV`, **own the lock** around your change.

---

## Batch processing with select lists (per-record locking)

```basic
SELECT F.ACCT WITH STATUS = "ACTIVE"

LOOP
  READNEXT ID ELSE EXIT
  READU R FROM F.ACCT, ID LOCKED CONTINUE     ;* skip busy
  * ... modify R ...
  WRITEU R ON F.ACCT, ID
  RELEASE F.ACCT
REPEAT
```

- **Never**: `READ` (no lock) → compute → `WRITE` later. That loses concurrent updates.

---

## Safe delete (two-phase check)

```basic
READU R FROM F.ACCT, ID LOCKED RETURN            ;* skip if busy
IF R<STATUS.A> # "CLOSED" THEN RELEASE F.ACCT ; RETURN
DELETEU F.ACCT, ID
RELEASE F.ACCT
```

Always verify **while locked** to avoid time-of-check/time-of-use issues.

---

## Unique ID/counter pattern (atomic increment)

```basic
OPEN "SEQ.FILE" TO F.SEQ ELSE ABORT 201,"SEQ.FILE"
KEY = "ACCOUNT.SEQ"
READU C FROM F.SEQ, KEY ELSE C = 0
C = C + 1
WRITEU C ON F.SEQ, KEY
RELEASE F.SEQ
NEW.ID = "100" : OCONV(C,"MD0")
```

Locking the counter guarantees uniqueness under concurrency.

---

## Idempotent write (change only if needed)

```basic
READU R FROM F.ACCT, ID LOCKED RETURN ELSE RETURN
IF R<FLAG.A> # "Y" THEN
  R<FLAG.A> = "Y"
  WRITEU R ON F.ACCT, ID
END
RELEASE F.ACCT
```

Reduces unnecessary writes and lock time.

---
## Troubleshooting & guardrails

- **Forgot `RELEASE`?** You’ll leave stuck locks (COB blockers). Ensure every exit path unlocks.
- **Busy a lot?** Shorten locked work; add retry/backoff; or **skip & log**.
- **Deadlocks?** If locking multiple records, **lock in a global order** (e.g., sort keys).
- **Status checks:** Where `LOCKED` clause isn’t available, use `STATUS()` right after I/O and branch on codes.

---
## Cheatsheet
|Task|Use|
|---|---|
|Open file|`OPEN "NAME" TO F ...`|
|Read (no lock)|`READ R FROM F, ID ELSE ...`|
|Read with lock|`READU R FROM F, ID LOCKED ... ELSE ...`|
|Write (no lock)|`WRITE R ON F, ID`|
|Write under lock|`WRITEU R ON F, ID` + `RELEASE F`|
|Delete under lock|`DELETEU F, ID` + `RELEASE F`|
|Iterate many|`SELECT F ...` + `READNEXT ID`|
|Skip busy|`READU ... LOCKED CONTINUE`|
|Single attribute|`READV / WRITEV` (still lock)|
|Free locks|`RELEASE filevar`|