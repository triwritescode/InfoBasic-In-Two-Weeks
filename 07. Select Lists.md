---
type: concept
tags:
  - InfoBasic
  - Programming
---
## What is a “select list”?

An **in-engine list of record keys (IDs)** produced by `SELECT …`. You iterate it with `READNEXT` to process many records without loading an entire file into memory.

---
## Core pattern (safe & idiomatic)

```basic
OPEN "ACCOUNT" TO F.ACCT ELSE ABORT 201,"ACCOUNT"

* 1) Build the list (optionally filtered/sorted; see §3)
SELECT F.ACCT

* 2) Iterate IDs, lock per-record, update, release
LOOP
   READNEXT ID ELSE EXIT                     ;* end of list
   READU REC FROM F.ACCT, ID LOCKED CONTINUE ;* skip busy record
   * ... validate & modify REC ...
   WRITEU REC ON F.ACCT, ID
   RELEASE F.ACCT
REPEAT

* 3) (Optional) Drop list explicitly
CLEARSELECT
```

Why this works:

- **No full table scan in memory** (engine streams IDs).
- **Lock per record only** → minimal contention.
- Guaranteed “visit each ID once” for the selected set.

---
## Building the list

### 1. Simple (all records)

```basic
SELECT F.ACCT
```

### 2. Filtered (dictionary-based)

Use dictionary item names if available (preferred—lets engine use indexes):

```basic
SELECT F.ACCT WITH STATUS = "ACTIVE" AND CURRENCY = "IDR"
```

If you don’t have dictionary items, select all then filter inside the loop.

### 3. Sorted

```basic
SSELECT F.ACCT BY BRANCH BY-DSND OPEN.DATE
```

- `SSELECT` (or `SELECT ... BY ...`) returns IDs **in order**.
- `BY` ascending, `BY-DSND` descending.
- Sorting costs time/memory—only use when you really need ordered processing.

---
## Variations you’ll actually use

**Bounded retries for lock contention**

```basic
LOOP
  READNEXT ID ELSE EXIT
  OK = 0
  FOR T = 1 TO 3
     READU R FROM F.ACCT, ID LOCKED
        CALL SLEEP.MS(100) ; CONTINUE        ;* tiny backoff
     END ELSE
        GOTO NOTFOUND                        ;* unexpected
     END
     OK = 1 ; EXIT
  NEXT T
  IF NOT(OK) THEN CONTINUE                   ;* give up this ID

  * ... process R ...
  WRITEU R ON F.ACCT, ID
  RELEASE F.ACCT
REPEAT
```

**Process only a subset (throttle)**

```basic
COUNT = 0
LOOP
  READNEXT ID ELSE EXIT
  COUNT += 1
  IF COUNT > 5000 THEN EXIT
  ...
REPEAT
```

**Skip by business rule inside the loop**

```basic
IF R<STATUS.ATTR> # "ACTIVE" THEN RELEASE F.ACCT ; CONTINUE
```

**Build an in-memory set from an enquiry/export and loop**

```basic
LIST = "A001@VMA002@VMA003"   ;* IDs from elsewhere
CONVERT @VM TO @AM IN LIST    ;* optional normalization
SELECT LIST                   ;* select from the string list
LOOP ; READNEXT ID ELSE EXIT ; ... ; REPEAT
```

_(Dialect-dependent; if unsupported, loop the MV list with `DCOUNT` instead.)_

---
## Correctness & safety rules

1. **Never**: `READ` (no lock) → compute → `WRITE` later.  
    → Risk of **lost updates**. Always `READU` → `WRITEU` → `RELEASE`.
2. Keep the **critical section tiny** (between `READU` and `RELEASE`).
3. Always handle the three outcomes: **found+locked**, **busy (LOCKED)**, **not found**.
4. Don’t hold **multiple locks** in unknown order → deadlocks. If you must, lock in a **global order** (e.g., ascending IDs).
5. After a failed path (validation error, exception), **ensure `RELEASE`** before `CONTINUE`/`RETURN`.

---
## Performance tips

- **Filter with dictionary fields** (`WITH STATUS = ...`) so the engine can use indexes.  
    If not available, consider creating/using app-level enquiries/indices, or filter inside the loop.
- Prefer **unsorted `SELECT`** unless ordering is essential; sorting (`SSELECT`/`BY`) adds overhead.
- **Batch in chunks** (e.g., 5k–50k records) and **checkpoint** progress (last ID processed) so you can resume.
- Hoist invariants **outside** the lock (case conversion, regex/masks, precomputed parameters).

---
## Debugging patterns

**Log progress every N records**

```basic
IF MOD(COUNT,1000)=0 THEN CRT "Processed: " : COUNT
```

**Detect empty result set**

```basic
SELECT F.ACCT
READNEXT ID ELSE CRT "No records found" ; GOTO DONE
; put ID back if you need full pass → re-SELECT or process ID then continue
```

**Measure elapsed time** (if you have a timing util) and report throughput.

---
## Common mini-recipes

**Sum a multivalue fee across active accounts**

```basic
TOTAL = 0
SELECT F.ACCT WITH STATUS = "ACTIVE"
LOOP
  READNEXT ID ELSE EXIT
  READ R FROM F.ACCT, ID ELSE CONTINUE     ;* pure read is fine for reporting
  N = DCOUNT(R<FEES.ATTR>, @VM)
  FOR I = 1 TO N
     V = R<FEES.ATTR, I>
     IF NUM(V) THEN TOTAL += V
  NEXT I
REPEAT
CRT OCONV(ROUND(TOTAL,2),"MR2")
```

**Bulk flag update with contention skip**

```basic
SELECT F.ACCT WITH DORMANT = "N" AND BALANCE = 0
LOOP
  READNEXT ID ELSE EXIT
  READU R FROM F.ACCT, ID LOCKED CONTINUE
  R<DORMANT> = "Y"
  WRITEU R ON F.ACCT, ID
  RELEASE F.ACCT
REPEAT
```

---
## Cheatsheet
|Task|Statement|
|---|---|
|Build list (all)|`SELECT filevar`|
|Filter list|`SELECT filevar WITH FIELD = "VAL" [AND/OR ...]`|
|Sorted list|`SSELECT filevar BY FIELD [BY-DSND FIELD2]`|
|Iterate|`READNEXT ID ELSE EXIT`|
|Lock & read|`READU REC FROM filevar, ID LOCKED CONTINUE`|
|Write under lock|`WRITEU REC ON filevar, ID`|
|Release|`RELEASE filevar`|
|Drop list|`CLEARSELECT`|