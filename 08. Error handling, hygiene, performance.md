---
type: concept
tags:
  - InfoBasic
  - Programming
---
## Error handling (predictable & actionable)

### 1. Classify errors

- **Validation (user/data):** missing/invalid field, rule breach
- **Contention:** record lock busy (`READU … LOCKED`)
- **I/O/system:** not found, file closed, STATUS() ≠ 0, COB window issues
- **Business conflict:** state disallows action (e.g., already posted)

### 2. Return contract (subroutines)

Use a consistent triad: `OK`, `ERR.CODE`, `ERR.MSG` (+ optional `DETAIL`).

```basic
SUBROUTINE ACCRUE.ONE(F.ACC, ID, OK, ERR.CODE, ERR.MSG)
   OK = 0 ; ERR.CODE = "" ; ERR.MSG = ""
   READU R FROM F.ACC, ID LOCKED
      ERR.CODE = "LOCK" ; ERR.MSG = "Record busy" ; RETURN
   END ELSE
      ERR.CODE = "NOTFND" ; ERR.MSG = "Account not found" ; RETURN
   END

   IF NOT(NUM(R<BAL.A>)) THEN
      ERR.CODE = "VAL.NUM" ; ERR.MSG = "Balance not numeric"
      GOTO CLEANUP
   END

   * ... modify R ...
   WRITEU R ON F.ACC, ID
   OK = 1
CLEANUP:
   RELEASE F.ACC
RETURN
```

**Conventions**

- **Never ABORT** in shared code; bubble errors via outputs.
- Always **RELEASE** on every exit path.
- For **contention**, either **retry with backoff** or **skip** (log).

### 3. Bounded retry (contention)

```basic
OK=0
FOR T=1 TO 3
  READU R FROM F, ID LOCKED
     CALL SLEEP.MS(100*T) ; CONTINUE
  END ELSE
     RETURN         ;* not found
  END
  OK=1 ; EXIT
NEXT T
IF NOT(OK) THEN ; *log skip* ; RETURN
```

### 4. Logging (don’t spam CRT)

Adopt a small logger wrapper (timestamp, program, company, user, key, corr-id, code, msg). Mask PII.

```basic
SUBROUTINE LOG.ERROR(CODE, MSG, KEY, CORR) ; *write to app log file/enquiry* ; RETURN
```

---
## Code hygiene (defensive & maintainable)

- **Validate inputs early** (before locking):
    - `NUM()`, date parse with `ICONV`, `LOCATE` in allowed lists.
- **Normalize once**: `U = UPCASE(s)` outside loops; keep **internal** dates/amounts (only `OCONV` at I/O).
- **Avoid globals (`COMMON`)**; pass file vars & options as args.
- **Name things**: constants for attribute numbers; no magic indexes.

```basic
EQU BAL.A TO 10 ; EQU PHONES.A TO 12
```

- **Parameterize** rather than hardcode (fees, thresholds).
- **Idempotency** for mutating routines:
    - Check “already applied?” before writing; make writes **deterministic**.
- **Short critical sections**:
    - Do heavy string math **before** `READU`; modify/write/unlock quickly.
- **No UI in core**: no `CRT` in production logic; return messages to the caller.
- **Maker/checker & overrides**:
    - Respect standard approval flows; don’t bypass with code.

---
## Performance (make the hot path cheap)

### 1. Inside loops

- **Hoist invariants**: masks, regex-like `MATCHES` patterns, `UPCASE`.
- **Cache counts**:

```basic
N = DCOUNT(MV, @VM)
FOR I = 1 TO N ; V = MV<I> ; ... ; NEXT I
```

- Prefer **`LOCATE` in MV** over scanning strings.
- Use **`READ`** (no lock) for pure reporting; **`READU`** only when changing.

### 2. Select lists

- Filter with **dictionary fields** so indexes help:

```basic
SELECT F.ACCT WITH STATUS="ACTIVE" AND CURRENCY="IDR"
```

- Avoid sorting unless required: `SELECT` (fast) > `SSELECT/BY` (costly).
- Process in **chunks** (e.g., 5k–50k) and checkpoint last ID.

### 3. Conversions & formatting

- **Do not** `OCONV` in inner loops for data you won’t display; keep numeric.
- Convert CSV↔MV with **`CONVERT`** (fast) instead of `CHANGE` when possible.

### 4. Locking

- Lock **one record at a time**; if you must lock multiple, use a **global order** to avoid deadlocks.
- Backoff on contention; **skip** after N attempts; log.

---
## Ready-to-use mini-templates

### 1. Guard-clause validator

```basic
SUBROUTINE VALIDATE.INPUT(AMT, CURR, OK, ERR)
  OK=0 ; ERR=""
  IF NOT(NUM(AMT)) THEN ERR="Amount not numeric" ; RETURN
  IF AMT <= 0 THEN ERR="Amount <= 0" ; RETURN
  IF NOT(LOCATE(UPCASE(CURR)) IN "IDR":@VM:"USD":@VM:"EUR") THEN ERR="Bad currency" ; RETURN
  OK=1
RETURN
```

### 2. Safe read-modify-write

```basic
SUBROUTINE ADD.FEE(F.ACC, ID, FEE, OK, ERR)
  OK=0 ; ERR=""
  READU R FROM F.ACC, ID LOCKED
     ERR="Busy" ; RETURN
  END ELSE
     ERR="Not found" ; RETURN
  END
  IF NOT(NUM(R<FEE.A>)) THEN R<FEE.A>=0
  R<FEE.A> += FEE
  WRITEU R ON F.ACC, ID
  OK=1
  RELEASE F.ACC
RETURN
```

### 3. Batch with throttle & progress

```basic
COUNT=0
SELECT F.ACCT WITH STATUS="ACTIVE"
LOOP
  READNEXT ID ELSE EXIT
  READU R FROM F.ACCT, ID LOCKED CONTINUE
  * ... mutate ...
  WRITEU R ON F.ACCT, ID
  RELEASE F.ACCT
  COUNT+=1
  IF MOD(COUNT,1000)=0 THEN CALL LOG.INFO("PROGRESS", "Processed ":COUNT, "", CORR)
REPEAT
```

---
## Pre-deploy checklist

 - Inputs validated (numeric, date, membership)
 - All READU paths RELEASE in all returns
 - Contention handled (retry/skip + log)
 - No CRT/debug left; sensitive data masked in logs
 - Attribute constants documented; no magic numbers
 - Loop invariants hoisted; no unnecessary OCONV in hot path
 - Batch chunking & resume plan (checkpoint)
 - Unit tests for validators/formatters; E2E on a sample set
 - Respect maker/checker; no direct GL posting from ad-hoc code